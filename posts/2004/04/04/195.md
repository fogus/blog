<b>How to be a Computer Scientist: Part 1 - Starting a Library (roots)</b>
<br />
<br /><i>Basics </i>
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0735611319/qid=1081138605/sr=1-3/ref=sr_1_3/102-3451934-7886550?v=glance&s=books">Code</a>
<br /><code>Petzold gets a bad rap from the hardcore programmers because of his affinity for writing Windows-centered books.  However, with <i>Code</i>, he has created a beautiful piece of work for the computer scientist N3wb33 (and for the guru too).  It starts from the ground up and gives a nice overview of Computer Science-ness.  This may be a great book to read if you are wavering on starting C.S. studies; it may push you one way or another, but in any case it is extremely informative.  Be warned, that there is a lot to be covered, and the topics in the books tend to be spread extremely thin, therefore be prepared to use the last entry in this category extensively as a supplement to <i>Code</i>.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0131103628/ref=cm_bg_f_2/102-3451934-7886550?v=glance">C</a>
<br /><code>There are many that believe that C is the wrong language to learn when starting as a computer scientist because it tends to be far too low-level.  There is something to be said for that (see the next book below for an alternative to this approach).  I started with BASIC myself, and because of it I developed many bad habits that I was only able to shake after many years of intensive programming.  In addition, because of the nature of BASIC, I was abstracted from the workings of the computer itself.  Therefore, I am of the school of thought that says one should start with a language that abstracts the machine a bit, but also allows you to dig as deeply as you wish to explore it completely.  C is this language.  Experimentation is important.  Causing memory protection faults is important.  Bit-manipulation is important.  Pointers are important.  It's all part of a solid foundation.   Kernighan and Dennis Ritchie invented the C language, and their views on the matter should be the starting point.  There book is quite terse, but it provides everything necessary to start with C -- besides, the best way to learn a language is to write programs in it.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0262011530/ref=ase_martyhallsrecomm/104-0706079-0483121?v=glance&s=books">Structure and Interpretation of Computer Programs</a>
<br /><code>Of course, starting with C causes beginners (and gurus at times) to get caught up in the minutiae of programming.  That is, basic C does very little for you.  By that, I am referring to the fact that if one were to implement any system in C, he/she would have to develop every aspect of the said system.  Every required data structure, every required algorithm, and basic memory juggling tasks must be handled by the programmer.  Very little, if anything is given to you with C.  Therefore, it may be a good idea to start your C.S. training with a language, namely Scheme, that provides a much higher level of abstraction, handles all memory manipulation tasks, provides powerful data structures 'right out of the box', and is extremely powerful for any programming task.  The <i>Structure and Interpretation of Computer Programs</i> book provides a great grounding in essential development knowledge, which will help you to avoid many bad habits from the start.  </code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0262032937/ref=cm_bg_d/102-3451934-7886550?v=glance">Algorithms</a>
<br /><code>It is absolutely critical that one gain an understanding about how algorithms are constructed, and what makes them great (or horrible as the case may be).  Any study of algorithms should be language independent, as the underlying ideas are truly the important matters.  In addition, any study of algorithms should be rooted heavily in mathematics, including: Combinatrics, Big O, probability, NP-completeness, and indirect/direct proofs.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201657880/qid=1081139477/sr=1-1/ref=sr_1_1/102-3451934-7886550?v=glance&s=books">Programming Pearls</a>
<br /><code>The quintessential problems book.  Expert chess masters spend countless hours every day solving chess problems.  That is, they study countless volumes of chess positions and devise the most creative and/or theoretically sound solutions for each.  In order to be a computer scientist, one must think like a computer scientist; one must solve computer science problems.  <i>Programming Pearls</i> is a great book packed with problems, insights, and solutions for many basic (and many not-so-basic) C.S. topics.</code>
<br />
<br /><a href="http://www.wikipedia.org">Wikipedia</a>
<br /><code>While reading any of the books mentioned in my series, there will often be a need to explore topics further.  The fantastic web resource Wikipedia will provide the answers, if not pointers to, almost any topic that may need more attention.  Use it.... Often.</code>
<br />
<br /><i>Motivational</i>
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0316491977/qid=1081137982/sr=1-1/ref=sr_1_1/102-3451934-7886550?v=glance&s=books">The Soul of a New Machine</a>
<br /><code>Details the project to design and create an early 32-bit mini-computer.  It's an interesting thing to read about the geniuses that forged the very field that you may be interested in pursuing.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0071358927/ref=pd_sim_books_4/102-3451934-7886550?v=glance&s=books">Fire in the Valley</a>
<br /><code>A collection of anecdotes and case studies about the advent of the PC and the rise of Silicon Valley as a force in the industry.  If the names Bill Gates, Paul Allen, Steve Balmer, Steve Jobs, Steve Wozniak, John Draper, Lee Felsenstein, Adam Osborne, The Homebrew Computer Club, Altair, Apple, and Microsoft sound familiar, then this may be the book for you.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0141000511/ref=pd_sim_books_2/102-3451934-7886550?v=glance&s=books">Hackers</a>
<br /><code>Hackers are not the devious criminals depicted in the movies; they are instead the pioneers of the computer industry.  Without hackers, we would be reading our emails on an abacus.  Much like <i>Fire in the Valley</i>, <i>Hackers</i> details the emergence and influence of a rejected subculture that turned out to change the world.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0743411463/ref=pd_sim_books_2/102-3451934-7886550?v=glance&s=books">Cuckoo's Egg</a>
<br /><code>As a child I ran a BBS (Wikipedia to the rescue).  After reading <i>The Cuckoo's Egg</i> I seriously wanted a cracker to attempt to break into my system so that I could track him and thwart his attempts like the protagonist in the book.  Of course, not having a 2nd phone line restricted my BBS to uptime hours between 11pm and 4am, thus seriously limiting cracker-busting potential.  It's was still a great book.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0375505245/qid=1081138318/sr=1-1/ref=sr_1_1/102-3451934-7886550?v=glance&s=books">Masters of Doom</a>
<br /><code>I discovered this book recently and I feel strongly enough to include it in this list.  It details the rise if Id Software, the makers of Doom.  The greatest tales are easily those concerning the single-mindedness of the driven programmer (in this case, John Romero and John Carmack), although the stories of interoffice backstabbing are quite good as well.  Very few books have motivated me to code intensively like this one.</code>
<br />
<br /><a href="http://www.amazon.com/exec/obidos/tg/detail/-/0140291776/ref=pd_sim_books_1/102-3451934-7886550?v=glance&s=books">Insanely Great</a>
<br /><code>The story of the Apple Macintosh.  Anyone living in the western hemisphere knows of the zealotry that Apple Computers invokes.  This book nicely details just why that is.  Steve and Steve are gods.  Nuff said.</code>
<br />
<br /><i>Religion</i>
