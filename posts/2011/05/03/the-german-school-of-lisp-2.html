<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>the-german-school-of-lisp-2</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://blog.fogus.me/styles/reset.css" />
  <link rel="stylesheet" href="https://blog.fogus.me/styles/index.css" />
</head>
<body>
<div id="header">
  [<a href="https://www.fogus.me/">fogus.me</a>
  /<a href="https://blog.fogus.me/">send more paramedics</a>
  /<a href="https://https://discord.gg/NmdZB6NEyZ">read-eval-print-λove</a>
  /<a href="https://www.github.com/fogus/">src</a>]
</div>
<p>The German school of Lisp is described by <a
href="http://kazimirmajorinc.blogspot.com/2011/04/one-picolisp-snippet.html">Kazimir
Majorinc</a> as a Spartan movement[^mini] in Lisp implementation. But
let me be clear, the Lisps in question are not toys like the one’s
littering the Lisp landscape (including <a
href="http://github.com/fogus/lithp">my own</a>). Likewise, these Lisps
are not libraries nor are they full-blown development ecosystems.</p>
<p>Let’s explore these distinctions for just a moment to clarify my
meaning.</p>
<figure>
<img src="http://images.fogus.me/blog/lisps.png"
title="The space between" alt="Lisps" />
<figcaption aria-hidden="true">Lisps</figcaption>
</figure>
<p>This post deals with that crimson space between, but first…</p>
<h2 id="exo-lisps">Exo-Lisps</h2>
<p>Exo-Lisps are the variants that exist to serve very pointed use
cases. They can take the form of highly specialized libraries or
embeddables like <a
href="http://people.csail.mit.edu/gregs/ref-dyn-patterns.html">GLOS</a>
or <a href="http://lush.sourceforge.net/">Lush</a>. Likewise, Exo-Lisps
may facilitate embedding within applications or act as extension
frameworks like <a href="http://www.gnu.org/s/guile/">Guile</a>, <a
href="http://usa.autodesk.com/adsk/servlet/index?siteID=123112&amp;id=770237">Visual
Lisp</a>, <a href="http://sam.zoy.org/elk/">Elk</a>, and <a
href="http://www.gnu.org/software/emacs/emacs-lisp-intro/">Emacs
Lisp</a>. Finally, Exo-Lisps like <a
href="https://github.com/rvirding/lfe">LFE</a> and <a
href="http://lambda-the-ultimate.org/node/2363">Liskell</a> serve as
skins over the semantics of another language.</p>
<h2 id="practical-lisps">Practical Lisps</h2>
<p>Practicality is a relative term. Having said that, there are clearly
a set of Lisps that exist primarily to solve “real world” problems,
including: <a href="http://common-lisp.net/">Common Lisp</a>, <a
href="http://clojure.org">Clojure</a>, <a
href="http://www.schemers.org/">Scheme (R5RS, R6RS, R7RS-big)</a>, <a
href="http://racket-lang.org/">Racket</a>, <a
href="http://www.call-cc.org/">Chicken Scheme</a>, and <a
href="http://www.opendylan.org/">Dylan</a>. I’m tempting libel cases by
including this particular category and filling it with these particular
choices, but so be it.</p>
<h2 id="kernel-lisps">Kernel Lisps</h2>
<p>I struggled to find a way of separating Exo-Lisps and Kernel Lisps
and the following distinction from this struggle arose. Where Exo-Lisps
serve as a framework for a specific problem, Kernel Lisps serve as a
framework for a more general problem – language development and
experimentation. Perhaps I’m splitting hairs. Some examples of Kernel
Lisps include: <a
href="https://groups.google.com/forum/#!topic/comp.lang.scheme/MCfPoeir90s">R7RS-small</a>,
<a href="http://s48.org">Scheme48</a>, <a
href="http://en.wikipedia.org/wiki/Lisp_Machine_Lisp">Lisp Machine
Lisp</a>, <a
href="http://people.bath.ac.uk/masjap/EuLisp/eulisp.html">EuLisp</a>,
and <a href="http://www.gnu.org/software/kawa/">Kawa</a>.</p>
<h2 id="pedagogical-lisps">Pedagogical Lisps</h2>
<p>As I alluded to earlier, the <a
href="http://www.google.com/search?sourceid=chrome&amp;ie=UTF-8&amp;q=toy+lisp">Lisp
landscape is rife with toys</a>, <a
href="http://axisofeval.blogspot.com/2010/08/no-more-minimal-early-lisps-pulleezz.html">Ur-Lisps</a>,
and half implementations. However, the vast majority of these Lisps
exist for pedagogical pursuits and are rarely (if ever) overtly
practical[^overt].</p>
<h2 id="fluchtpunkt-lisps">Fluchtpunkt Lisps</h2>
<p>Fluchtpunkt Lisps skirt the vanishing point between theory,
practicality, and art. These implementations are all of the other
categories in some way, while simultaneously being none in particular.
They may or may not be general purpose languages in all instances, but
they are all driven by a fervent ideal.</p>
<p>Below is a list of Fluchtpunkt Lisp implementations that I’ve found,
and some discussion of their driving ideal (as I understand):</p>
<h4 id="t"><a href="http://mumble.net/~jar/tproject/">T</a></h4>
<p>T is my favorite Scheme variant and the inspiration for many a Lisp
thereafter. I’ve poured over <a
href="http://www.amazon.com/o/asin/013881905X?tag=fogus-20">Stephen
Slade’s T book</a> numerous times, finding something mind blowing each
time. The primary driving force behind T was to prove that a Scheme
could be made to run extremely fast, and fast it ran. T’s compiler
technology was the motivation for numerous dissertations, and remains
influential in many ways, even if some of its compilation techniques
have fallen out of fashion.</p>
<h4 id="qishen"><a
href="http://www.lambdassociates.org/Lib/libraries.htm">Qi/Shen</a></h4>
<p>Qi (and its successor Shen) really push the limits of what we might
call a Fluchtpunkt Lisp. I suspect it requires a categorization of its
own.</p>
<p>A few years ago I was looking for a Lisp to dive into and my
searching uncovered two extremely interesting options: Clojure and Qi. I
eventually went with Clojure, but in the intervening time I’ve managed
to spend quality time with Qi and I love what I’ve seen so far. Qi’s
confluence of features, including an optional type system (actually, its
type system might be more accurately classified as “skinnable”), pattern
matching,[^patt] and an embedded logic engine based on Prolog, make it a
very compelling choice indeed.</p>
<h4 id="newlisp"><a href="http://www.newlisp.org/">newLISP</a></h4>
<p>newLISP raised some ire at one point or another because of its design
choices, specifically its choice of pervasive dynamic scope and <a
href="http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf">fexprs</a>
(pdf).[^fexprs] I like dynamic scope under some circumstances, but I
can’t say that I’ve followed it to its logical end for any application
of significant size or complexity. The advocates of newLISP are
interesting folk and in many ways of my own mind. For example, how would
one <a href="">calculate Pi out to <code>n</code> digits in
newLISP</a>?</p>
<pre><code>(define (pi n)
 (replace &quot;\\&quot; (join (exec 
   (format &quot;echo &#39;scale=%d; 4 * a(1)&#39; | bc -ql&quot; n))) 
   &quot;&quot;))

(pi 30) 
;=&gt; &quot;3.1415926535897932384626433832795028841968&quot;</code></pre>
<p>Why you would call out to the UNIX <code>bc</code> command of course.
Why would you need your programming language to provide that type of
calculation[^mul] when there are more appropriate tools for doing so? I
suppose the fundamental philosophy of newLISP is to not necessarily
provide everything, but to make everything possible. newLISP facilitates
possibility by treating the use of <code>eval</code> as a first-class
approach and utterly idiomatic.</p>
<h4 id="arc"><a href="http://www.paulgraham.com/arc.html">Arc</a></h4>
<p>I agonized over including Paul Graham’s Arc in the category of
Fluchtpunkt Lisp, but I think this is the correct place for it. The
driving forces behind Arc are <a
href="http://www.paulgraham.com/power.html">succinctness</a> and <a
href="http://www.paulgraham.com/hundred.html">centenarianism</a> – both
of which are certainly emblematic of the Fluchtpunkt ideal. Arc hasn’t
taken off as much as non-Paul-Graham humans would have liked, but I
believe that the root of the problem is that they prayed for Practical,
but instead got Fluchtpunkt.</p>
<h4 id="pico-lisp"><a href="http://picolisp.com/5000/-2.html">Pico
Lisp</a></h4>
<p>I first came across Pico Lisp when reading the paper <a
href="http://software-lab.de/radical.pdf">“Pico Lisp: A Radical Approach
to Application Development”</a> by Alexander Burger and was instantly
fascinated. The primary goal is to provide an idealized Lisp interpreter
that runs as fast as possible. To accomplish this goal Pico Lisp limits
its feature set and optimizes the code path along the dimensions of its
features. The core types provided by Pico Lisp are numbers, symbols, and
lists. Given the paucity of these types Pico Lisp has the advantage of
always taking the most direct interpretation path and thus avoiding any
unnecessary checks and abstractions that a more corpulent Lisp might
require. For example, Pico Lisp’s <code>quote</code> function is defined
in such a way that it returns all of its arguments unevaluated allowing
the operation of <code>quote</code> to optimize into only a return of
its <code>cdr</code> rather than the <code>car</code> of its
<code>cdr</code>. Simple no?</p>
<p>Pico Lisp is, in my opinion, the most interesting entry in a family
of <em>really really small Lisps</em> that also includes <a
href="http://www-fourier.ujf-grenoble.fr/~sergerar/Nanolisp/">Nanolisp</a>
and <a href="http://code.google.com/p/femtolisp/">femtoLisp</a>,
although I would hesitate to include these latter two in the Fluchtpunkt
category.</p>
<h4 id="wasp-lisp"><a href="http://sites.google.com/site/waspvm/">Wasp
Lisp</a></h4>
<p>Wasp Lisp is a small Scheme inspired by Erlang with lightweight
cooperative threads, communication via channels, and an implementation
of [MOSREF</p>
<div id="footer">
  <a href="https://blog.fogus.me/">send more paramedics</a> 
  &copy; 2002-2024 <a href="https://www.fogus.me/">Fogus</a>
</div>
</body>
</html>
