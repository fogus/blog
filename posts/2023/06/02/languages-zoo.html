<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>languages-zoo</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="https://blog.fogus.me/styles/reset.css" />
  <link rel="stylesheet" href="https://blog.fogus.me/styles/index.css" />
</head>
<body>
<div id="header">
  [<a href="https://www.fogus.me/">fogus.me</a>
  /<a href="https://blog.fogus.me/">send more paramedics</a>
  /<a href="https://https://discord.gg/NmdZB6NEyZ">read-eval-print-λove</a>
  /<a href="https://www.github.com/fogus/">src</a>]
</div>
<p>As long as I can remember I have loved the process of defining,
designing, and implementing my own programming languages. I’ve created
so many languages that you could say that I’ve created something of a <a
href="https://plzoo.andrej.com/">programming languages zoo</a>. Below
you’ll find a list of the languages that I’ve created over the years and
those that I’m thinking about currently.</p>
<p><a id="org1d1c742"></a></p>
<h2 id="active-projects">Active projects</h2>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
Project
</th>
<th scope="col" class="org-left">
Status
</th>
<th scope="col" class="org-left">
Synopsis
</th>
<th scope="col" class="org-left">
Impl langs
</th>
<th scope="col" class="org-left">
Next Goals
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
Clojure
</td>
<td class="org-left">
maintainer
</td>
<td class="org-left">
The Clojure programming language
</td>
<td class="org-left">
Java + Clojure
</td>
<td class="org-left">
[ ] keep rockin’
</td>
</tr>
<tr>
<td class="org-left">
Cribbaj
</td>
<td class="org-left">
<a href="https://github.com/fogus/thunks/blob/main/langdev/forth.txt">delimiting</a>
</td>
<td class="org-left">
An implementation of Forth with IDE and VM
</td>
<td class="org-left">
C + Ruby + Cribbaj
</td>
<td class="org-left">
[ ] kernel-forth definition
</td>
</tr>
<tr>
<td class="org-left">
Folog
</td>
<td class="org-left">
prototyped
</td>
<td class="org-left">
An Prolog implementation
</td>
<td class="org-left">
Common Lisp
</td>
<td class="org-left">
[ ] port to CLJ
</td>
</tr>
<tr>
<td class="org-left">
Quincunx
</td>
<td class="org-left">
prototyped
</td>
<td class="org-left">
A small functional language with FEXPRs
</td>
<td class="org-left">
Clojure -&gt; C
</td>
<td class="org-left">
[ ] read and annotate
<a href="https://web.cs.wpi.edu/~jshutt/kernel.html">Shutt</a>
</td>
</tr>
<tr>
<td class="org-left">
Incal
</td>
<td class="org-left">
documenting
</td>
<td class="org-left">
Minimal implementation of the J language
</td>
<td class="org-left">
C
</td>
<td class="org-left">
[ ] org-mode babel
</td>
</tr>
<tr>
<td class="org-left">
Ix
</td>
<td class="org-left">
dev
</td>
<td class="org-left">
An OO language with production rules
</td>
<td class="org-left">
C + Ix
</td>
<td class="org-left">
[ ] test harness [ ] vectors
</td>
</tr>
<tr>
<td class="org-left">
Juxt
</td>
<td class="org-left">
prototyped
</td>
<td class="org-left">
A functional concatenative language
</td>
<td class="org-left">
Java + Juxt
</td>
<td class="org-left">
[ ] reader impl
</td>
</tr>
<tr>
<td class="org-left">
Lithp
</td>
<td class="org-left">
<a href="https://github.com/fogus/lithp">released</a>
</td>
<td class="org-left">
An implementation of McCarthy’s original LISP w/ macros
</td>
<td class="org-left">
Python + Lithp
</td>
<td class="org-left">
[ ] perpetual hacking
</td>
</tr>
<tr>
<td class="org-left">
Minderbinder
</td>
<td class="org-left">
prototyped
</td>
<td class="org-left">
An RPN command line calculator with units of measure
</td>
<td class="org-left">
Python / Clojure
</td>
<td class="org-left">
[ ] define uom specs
</td>
</tr>
<tr>
<td class="org-left">
µPy
</td>
<td class="org-left">
dev
</td>
<td class="org-left">
A very small implementation of Python
</td>
<td class="org-left">
C + Python
</td>
<td class="org-left">
[ ] decorators
</td>
</tr>
</tbody>
</table>
<p><a id="org43b9874"></a></p>
<h3 id="clojure">Clojure</h3>
<p>I’ve been a full-time member of the <a
href="https://www.clojure.org">Clojure</a> core team <a
href="https://blog.fogus.me/2021/01/15/clojure-core/">for two-years</a>
and have worked to maintain, fix, and enhance the language and
ecosystem. I certainly would not say that Clojure is “my” language, not
even a little bit, but I have contributed enough to warrant mention.
Perhaps one day when the Clojure history book is written I will get a
paragraph.</p>
<p><a id="orgf745b0f"></a></p>
<h3 id="cribbaj">Cribbaj</h3>
<p>Cribbaj is a Forth implementation that’s intended to start with the
<a
href="https://forth.sourceforge.net/standard/fst83/index.html">Forth-83</a>
spec and expand into a more modern and portable implementation. The
ideas that I would like to explore with Cribbaj are meta-compilation,
meta-programming, kernel-Forths, IDE design, and batteries-included
language implementation. The historical precedents for Cribbaj include:
<a href="https://en.wikipedia.org/wiki/KAMAS_(program)">KAMAS</a>,
Forth-83, <a
href="https://www.millermicro.com/mmsforth.html">MMSForth</a>, <a
href="https://www.retrotechnology.com/memship/figforth_1802.html">FIG
Forth</a>, and <a
href="https://en.wikipedia.org/wiki/ColorForth">colorForth</a>.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li><a
href="https://www.forth.com/wp-content/uploads/2018/11/thinking-forth-color.pdf">Thinking
Forth</a> (pdf) by Brodie</li>
<li><a
href="https://www.amazon.com/Threaded-Interpretive-Languages-Design-Implementation/dp/007038360X/?tag=fogus-20">Threaded
Interpretive Languages</a> by Loeliger</li>
<li><a
href="https://www.amazon.com/Forth-Text-Reference-Prentice-Hall-Software/dp/0133263312/?tag=fogus-20">Forth:
A Text and Reference</a> by Kelly and Spies</li>
<li><a
href="https://archive.org/details/designingprogram0000town">Designing
&amp; Programming Personal Expert Systems</a> by Townsend Feucht</li>
<li><a
href="https://www.amazon.com/Object-Oriented-Forth-Dick-Pountain/dp/0125635702?tag=fogus-20">Object-Oriented
Forth: Implementation of Data Structures</a> by Pountain</li>
<li>“<a href="https://www.youtube.com/watch?v=0PclgBd6_Zs">Programming a
144-computer chip to minimize power</a>” by Chuck Moore</li>
<li>“<a href="https://www.bradrodriguez.com/papers/moving1.htm">Moving
Forth</a>” by Brad Rodriguez</li>
<li>“<a href="https://leonardschuetz.ch/blog/nan-boxing/">Dynamic Typing
and NaN Boxing</a>” by Leonard Schütz</li>
</ul>
<p>Some thoughts and ideas about the direction that I’ll take Cribbaj is
found in <a
href="https://github.com/fogus/thunks/blob/main/langdev/forth.txt">my
thunks repo</a>.</p>
<p><a id="org3d64d60"></a></p>
<h3 id="folog">Folog</h3>
<p>Folog started as a fork of Hideyuki Nakashima’s <a
href="https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/impl/prolog/ppicl/0.html">PPiCL</a>
– an elegant and mind-warping little interpreter. I added extensions
such that I could in turn implement a little LISP in the language but I
have not taken it further. Eventually I would like to port the original
logic to Clojure and occasionally hack on it toward that goal.</p>
<p><a id="org15a0ea5"></a></p>
<h3 id="quincunx">Quincunx</h3>
<p>Quincunx is currently implemented as a mini interpreter written in
Clojure. The purpose was to better understand <a
href="https://en.wikipedia.org/wiki/Fexpr">FEXPRs</a>, and while I think
that goal was achieved, it would be nice to take it further. The natural
path is toward the Kernel language, but some study needs to happen on my
part before I can proceed. I would like to create a small interpreter in
C and explore simple GCs, but that is further in the future.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li><a
href="https://www.softwarepreservation.org/projects/LISP/book/LISP%201.5%20Programmers%20Manual.pdf">LISP
1.5 Programmer’s Manual</a> (pdf) by McCarthy, et al.</li>
<li>“vau-calculi and the theory of fexprs” by John Shutt</li>
<li>“The Theory of Fexprs is Trivial” by Mitchell Wand</li>
<li><a href="http://fexpr.blogspot.com/">John Shutt’s blog
archive</a></li>
<li>“<a href="https://bernsteinbear.com/blog/small-objects/">Small
objects and pointer tagging</a> by Max Bernstein</li>
</ul>
<p><a id="orgfe1ca5a"></a></p>
<h3 id="incal">Incal</h3>
<p>This started as the original C implementation, <a
href="https://code.jsoftware.com/wiki/Essays/Incunabulum">J
Incunabulum</a> but I took the effort to translate the code into a style
that fits my own style. Many similar efforts have since happened over
the years but this one is mine. I would like to eventually make a
literate version of this.</p>
<p><a id="org4e65eb8"></a></p>
<h3 id="ix">Ix</h3>
<p>Ix is a language that I’ve been hacking on for 20 years. The seed of
Ix is found in <a href="https://www.clipsrules.net/">CLIPS</a>,
especially in the COOL subsystem. The central conceit of Ix is this: <a
href="https://leanpub.com/readevalprintlove004/read#leanpub-auto-production-rules-and-oop">can
we mitigate the complexity of object-oriented programming by describing
and scoping instance mutation in-terms of production rules</a>?</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li><a
href="https://www.amazon.com/exec/obidos/tg/detail/-/0534384471/?tag=fogus-20">Expert
Systems: Principles and Programming</a> by Giarratano and Riley</li>
<li><a
href="http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf">Smalltalk-80:
the language and its implementation</a> (pdf) by Goldberg and
Robson</li>
<li><a href="https://www.cs.rit.edu/~ats/books/ooc.pdf">Object-oriented
Programming with ANSI-C</a> (pdf) by Axel-Tobias Schreiner</li>
<li><a
href="https://www.amazon.com/Semantic-Web-Working-Ontologist-Effective/dp/0123859654?tag=fogus-20">Semantic
Web for the Working Ontologist</a> by Deam Allemang</li>
<li><a
href="https://www.amazon.com/Efficient-Polymorphic-Springer-International-Engineering-ebook/dp/B000WNJ39E/?tag=fogus-20">Efficient
Polymorphic Calls</a> by Karel Driesen</li>
<li>“<a
href="https://bitsavers.org/pdf/xerox/smalltalk/Smalltalk-72_Instruction_Manual_Mar76.pdf">Smalltalk-72
Instruction Manual</a>” (pdf) by Goldberg and Kay</li>
<li>“Production Matching for Large Learning Systems” by Robert
Doorenbos</li>
</ul>
<p>Ix has been rewritten no less than three times and has gone from a
Smalltalk-like system to a Lisp-like system to something in-between. I
will probably hack on this until I die… in fact, it might kill me.</p>
<p><a id="org242d721"></a></p>
<h3 id="juxt">Juxt</h3>
<p>Juxt is very much inspired by <a
href="https://hypercubed.github.io/joy/joy.html">Joy</a> but I would
like to incorporate some of the ideas in Clojure. A prototype was
written in a weekend and allows code such as below:</p>
<pre><code>/swoncat (A B : B A)! cat/
/Y ($cons) swoncat $cons i/</code></pre>
<p>The code above implements the Y combinator and if you know Joy then
you’ll understand that the functions <code>cat</code> and
<code>$cons</code> are list manipulation operators. Indeed, Juxt (like
Joy) uses quotations as its lambda representation, which are simply
lists that may or may not have some context attached to them. If I were
to describe Juxt in one sentence it would be: a homoiconic, functional,
stack-based, concatenative programming language with: lexical scope,
closures, tail-recursion, a stack-effects mini-language, first-class
environments, destructuring, modules, metaprogramming support, dynamic
type checking, and Java interoperability. The simplicity of the language
is such that the kernel was written in a weekend and further features
like modules, recursion, lexical binding, and shuffle operators were
written over time in Juxt.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li>“<a
href="https://hypercubed.github.io/joy/html/j05cmp.html">Recursion
Theory and Joy”</a> by Manfred von Thun</li>
<li>“<a href="https://hypercubed.github.io/joy/html/j04alg.html">The
Algebra of Joy</a>” by Manfred von Thun</li>
<li><a
href="https://www.amazon.com/Arrows-Structures-Functors-Categorical-Imperative/dp/0120590603?tag=fogus-20">Arrows,
Structures and Functors: The Categorical Imperative</a> by Michael
Arbib</li>
<li><a
href="https://www.amazon.com/Architecture-Computers-McGraw-Hill-Supercomputing-Processing/dp/0070355967?tag=fogus-20">The
Architecture of Symbolic Computers</a> by Peter Kogge</li>
<li><a
href="https://www.amazon.com/Mock-Mockingbird-Raymond-Smullyan/dp/0192801422/?tag=fogus-20">To
Mock and Mockingbird</a> by Smullyan</li>
<li>“Can Programming be liberated from the von Neumann Style?” by J.W.
Backus</li>
<li>“Clean — a Language for Functional Graph Rewriting” by van Leer and
Plasmejer</li>
</ul>
<p><a id="org07ec53b"></a></p>
<h3 id="lithp">Lithp</h3>
<p><a href="https://github.com/fogus/lithp">Lithp</a> is an
implementation of an interpreter for the original LISP as described by
John McCarthy and the macro system described later by Timothy Hart. The
interpreter implements the following seven functions:</p>
<ol type="1">
<li><code>atom</code></li>
<li><code>car</code></li>
<li><code>cdr</code></li>
<li><code>cond</code></li>
<li><code>cons</code></li>
<li><code>eq</code></li>
<li><code>quote</code></li>
</ol>
<p>and also two special forms:</p>
<ol type="1">
<li><code>label</code></li>
<li><code>lambda</code></li>
</ol>
<p>Using these functions I also implemented a Lithp interpreter in Lithp
itself that implements the same 9 features and also added a
<code>macro</code> special form.</p>
<p><a id="org0236f81"></a></p>
<h3 id="minderbinder">Minderbinder</h3>
<p>Minderbinder started as a Clojure library of the same name providing
unit of measure conversions. However, over time it took on a life of its
own and has since morphed into a command line RPN calculator supporting
bignums and unit of measure awareness. It’s not a general solution yet
and needs some work to be usable by someone other than myself.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li><a href="https://frinklang.org/">The Frink Programming
Language</a></li>
<li><a
href="https://archive.org/details/algorithmsforrpn0000ball">Algorithms
for RPN Calculators</a> by John Ball</li>
</ul>
<p><a id="org9857696"></a></p>
<h3 id="µpy">µPy</h3>
<p>µPy is a spike of <a href="http://www.tinypy.org/">tinypy</a> by Phil
Hassey that I at one time considered for the front end to Ix (mentioned
above). However, I never went that far and instead left in some of the
features that Ix and later Python had, including:</p>
<ul>
<li>Tuples</li>
<li>MOP</li>
<li>Advice</li>
<li>A very hacky form of predicate dispatch</li>
</ul>
<p>I don’t know how far I will go with this.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li><a
href="https://direct.mit.edu/books/book/2607/The-Art-of-the-Metaobject-Protocol">The
Art of the Metaobject Protocol</a> by Kiczales, des Rivieres, and
Bobrow</li>
</ul>
<p><a id="org37d875f"></a></p>
<h2 id="paused-projects">Paused projects</h2>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup>
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">
Project
</th>
<th scope="col" class="org-left">
Status
</th>
<th scope="col" class="org-left">
Synopsis
</th>
<th scope="col" class="org-left">
Implementation
</th>
<th scope="col" class="org-left">
Eventual Goals
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">
370 ASM
</td>
<td class="org-left">
lost
</td>
<td class="org-left">
An assembler for a subset of IBM 370 assembly
</td>
<td class="org-left">
C
</td>
<td class="org-left">
[ ] invent time machine
</td>
</tr>
<tr>
<td class="org-left">
Baysick
</td>
<td class="org-left">
<a href="https://github.com/fogus/baysick">released</a>
</td>
<td class="org-left">
A embedded BASIC DSL
</td>
<td class="org-left">
Scala
</td>
<td class="org-left">
[ ] make work in Scala.latest
</td>
</tr>
<tr>
<td class="org-left">
Eleusis
</td>
<td class="org-left">
prototyped
</td>
<td class="org-left">
An implementation of microKanren
</td>
<td class="org-left">
Clojure
</td>
<td class="org-left">
[ ] speed up unification
</td>
</tr>
<tr>
<td class="org-left">
Mouse
</td>
<td class="org-left">
lost
</td>
<td class="org-left">
An implementation of the Mouse programming language
</td>
<td class="org-left">
C64 BASIC
</td>
<td class="org-left">
[ ] invent time machine
</td>
</tr>
<tr>
<td class="org-left">
Pascal
</td>
<td class="org-left">
lost
</td>
<td class="org-left">
A compiler for a subset of Pascal that targets a simple VM
</td>
<td class="org-left">
C
</td>
<td class="org-left">
[ ] invent time machine
</td>
</tr>
<tr>
<td class="org-left">
Russ-Forth
</td>
<td class="org-left">
<a href="https://github.com/fogus/russ-forth">released</a>
</td>
<td class="org-left">
A teeny-tiny Forth-esque
</td>
<td class="org-left">
Ruby
</td>
<td class="org-left">
[ ] stdlib
</td>
</tr>
<tr>
<td class="org-left">
Tori-Lisp
</td>
<td class="org-left">
<a href="https://github.com/fogus/tori-lisp">released</a>
</td>
<td class="org-left">
Small functional programming language
</td>
<td class="org-left">
JavaScript + Tori-Lisp
</td>
<td class="org-left">
[ ] in-broswer IDE
</td>
</tr>
<tr>
<td class="org-left">
μLithp
</td>
<td class="org-left">
<a href="https://github.com/fogus/ulithp">released</a>
</td>
<td class="org-left">
A micro LISP implementation in 24 lines
</td>
<td class="org-left">
Ruby
</td>
<td class="org-left">
[ ] interop
</td>
</tr>
</tbody>
</table>
<p><a id="orgec23df4"></a></p>
<h3 id="asm">370 ASM</h3>
<p>This was an IBM System/370 assembler that I wrote in college. It has
been lost to the dustbin of history.</p>
<p><a id="org3d668d4"></a></p>
<h3 id="baysick">Baysick</h3>
<p><a href="https://github.com/fogus/baysick">Baysick</a> is a Scala DSL
that allows embedded BASIC-like syntax. It worked on a version of Scala
circa 2009 but has not been maintained since.</p>
<p><a id="org46d6d96"></a></p>
<h3 id="eleusis">Eleusis</h3>
<p>Like everyone in the Clojure community, I also created an embedded
microKanren library. Eleusis was slightly different in that I also
implemented a REPL that read microKaren forms and executed them.</p>
<p>Some references that I’m using for design include:</p>
<ul>
<li>“<a
href="http://webyrd.net/scheme-2013/papers/HemannMuKanren2013.pdf">µKanren:
A Minimal Functional Core for Relational Programming</a>” by Hemann and
Byrd</li>
<li>“<a href="https://erik-j.de/microkanren/">A Gentle Introduction to
MicroKanren</a>” by Erik Derohanian</li>
</ul>
<p><a id="org6ca68d2"></a></p>
<h3 id="mouse">Mouse</h3>
<p>Possibly my first language was a janky implementation of the <a
href="https://en.wikipedia.org/wiki/Mouse_(programming_language)">Mouse
programming Language</a> on my old Commodore 64. I doubt that I
implemented the whole language but the parts that I did were simple
because the language can be implemented by simply walking an array of
bytes and calling dispatch subroutines for each byte. In all likelihood
I only implemented the mathematical operators and possibly
variables.</p>
<p><a id="org7ed0011"></a></p>
<h3 id="pascal">Pascal</h3>
<p>Also in college I implemented a 1-pass Pascal compiler that targeted
an intermediate quadruple language and a little interpreter for that
IL.</p>
<p><a id="orgad85e61"></a></p>
<h3 id="russ-forth">Russ-Forth</h3>
<p>I implemented <a
href="https://github.com/fogus/russ-forth">Russ-Forth</a> years ago
after being nerd-sniped by my old-friend Russ Olsen.</p>
<p><a id="orgc31f09b"></a></p>
<h3 id="tori-lisp">Tori-Lisp</h3>
<p><a href="https://github.com/fogus/tori-lisp">Tori-Lisp</a> is a code
riff that I created from from <a
href="https://github.com/maryrosecook/littlelisp">Mary Rose Cook’s
lovely Little Lisp</a>. The central conceit was: what would you need in
a Lisp that didn’t have macros but felt like it did?</p>
<p><a id="orgae9deac"></a></p>
<h3 id="μlithp">μLithp</h3>
<p><a href="https://github.com/fogus/ulithp">μLithp</a> was an
experiment to see if I could create a Lisp-like interpreter in less than
30 lines of Ruby. It took 24.</p>
<p>There are certainly more than those listed above, but any additional
exist only on dusty archives and not in my brain case. I can only hope
that they bubble to the surface one day.</p>
<p>:F</p>
<p><strong>note: <a
href="https://github.com/fogus/thunks/blob/main/langdev/zoo.txt">a
living version of this document is found on GitHub</a>.</strong></p>
<div id="footer">
  <a href="https://blog.fogus.me/">send more paramedics</a> 
  &copy; 2002-2024 <a href="https://www.fogus.me/">Fogus</a>
</div>
</body>
</html>
