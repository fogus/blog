Recently there was a wonderful post call "[The joys of having a forever project](http://www.dev.gd/20130122-the-joys-of-having-a-forever-project.html)" that was very motivational and got a lot of people excited.  Due to that post I went searching around and found a whole under-culture of forever projects on the Internet including a [SubReddit devoted to the topic](http://www.reddit.com/r/programmingforever/).  While I can understand the draw of a forever project,[^for] I've tended toward projects with an end; divided into chunks of 5, 3, 1 and 1/2 year timeframes.  Whenever I approach an exciting opportunity I try to imagine it as falling into one of the four bins.  This allows me to avoid chasing every shiny object that comes my way -- an urge that I have far too often.

[^for]: Of course I have my own forever project, but it's irrelevant what it is because it's purely indulgent.

5
----

A little over five years ago I wanted to start on a 5-year project.  A 5-year project is exactly what you think it is; something complicated enough to take five years to complete.  At the time I decided to create a variant of Scheme and had I continued doing so I'm certain that, five years later, the world would have yet another crappy Scheme variant.  I started my Scheme (named Broccoli) in earnest fully expecting to take five years to do it well enough to be proud.

Little did I expect that five years later I would have instead helped further the cause of a very different variant of Scheme/Lisp -- [Clojure](http://www.clojure.org).  Looking back on my five year goal of five years hence I clearly did not accomplish my goal, but I think that I gave more to the world than if I had.  Five year projects are funny that way; they can flail, go completely off the rails, they can morph and sometimes they can turn into lifetime projects.  My five-year project morphed, and thankfully for the best.[^os]

[^os]: My previous five-year project flailed and flailed, but thankfully I learned a lot about operating systems and myself during the process.

While I plan to continue working with and for Clojure, I'm kinda on the hunt for another five-year project.  I have a few ideas, but who knows what they'll look like in 2018.  I'm sure that I'll blog about it along the way.

3
----

A three-year project is more difficult to deal with and is long enough and ponderous enough to conflict with a concurrent five-year project.  My work on [core.contracts](https://www.github.com/clojure/core.contracts) is close to a three-year project, but I've been a bit wishy-washy on it and it should be further ahead than it actually is.  Something that I would have been proud to have started three-years ago is something like [Underscore.js](https://github.com/documentcloud/underscore/blob/0.1.0/underscore.js), [Riemann](http://aphyr.github.io/riemann/) or [Redis](http://redis.io/) -- a relevant library or system that many people find useful and generally kicks butt.  I've managed to release some useful libraries for sure, but I'd hardly consider them three-year projects.[^under]  I have a very nice plan for a three-year project that shouldn't conflict with anything else, but only time will tell.[^scifi]

[^under]: Or even a fraction as successful as Underscore or Redis.

[^scifi]: My [scifi ketchup](http://blog.fogus.me/2012/09/21/the-amazing-colossal-science-fiction-ketchup/) will probably take three years, so there's one. :-)

1
----

One-year projects are the simplest to manage because of their shorter time-frame.  Likewise, I've found that they're often easy to parallelize with other one-year projects, but that may be because I pick projects in different realms.  For example, in the past few years some of my 1-year projects have been:

 - Write a [Clojure book](http://www.joyofclojure.com)
 - Listen to everything that Béla Bartók ever composed [^bart]
 - Write a [book on functional programming](http://www.functionaljavascript.com) (ongoing)

Nothing earth-shattering for sure, but they're intentionally digestible, yet satisfying.  I have a couple of one-year projects that are closing out, and once again on the hunt.  I recently (re)discovered the joys of compression and algorithmic information theory and it would easily take a year to become even a rank amateur on the topic.

0.5
----

Half-year projects could be anything from reading a good book to a creating a well-documented software library or service to writing a poem.  My half-year projects are too numerous and disposable to mention, but I will say that a couple that I'm excited to get into whenever I'm done with my book projects are to *thoroughly* read both [AMOP](http://www.amazon.com/The-Metaobject-Protocol-Gregor-Kiczales/dp/0262610744/?tag=fogus-20) and [CTM](http://www.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695/?tag=fogus-20).

But of course there are infinitely many projects to be done at any given time, so how do you (well, me) choose which ones to work on?  I think [Derek Sivers said it best](http://sivers.org/hellyeah):

> No more yes. It's either HELL YEAH! or no.

What are your 5-3-1-0.5-year projects?

:F

[^bart]: You can *hear* everything that Bartók ever created in far less than a year, but it takes longer to *listen*.