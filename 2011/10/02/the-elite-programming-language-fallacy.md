There are no programming languages that will make you "elite".  In fact, there are no "elite" programming languages.  "Elite" is as loaded a term as there could possibly be, but I would like to use (abuse?) it for the purpose of this post.  I hope you will bear with me as I attempt to make a point.

## "Elite" Programming Languages

What is the primary characteristic that an "elite" programming language might posses?  It would be difficult to understand and use.  I think that every programming language is difficult to understand with little to no relevant context.  Even a language like Java that is partially designed for ease of introduction is not based in human nature.  That is, every Java programmer at one point or another knew nothing about Java, objects, and interfaces.  So I say that even a notoriously difficult language like Haskell is only difficult because you haven't learned it yet.  But what about the idea that some languages are built for "elite" programmers only?  I'll talk about that currently.

## "Elite" Programmers

What is an "elite" programmer.  It's difficult to say, but anyone with even a few years of experience is likely to have worked with one, or observed one, or maybe even studied one.  The best way to describe an "elite" programmer is simply:

> You just know one when you see one.

But does a programming language make a programmer "elite"?  Let me speak from my own experience.  In my time I've met and worked with my share of "elite" programmers:

* One knew every Java method available, could write Java faster than I could ever write anything, even at my most concise, and could simply "see" the flow of concurrent paths and points of contention.
* One spoke Emacs Lisp like it was a native tongue.  I could not visually follow the shuffling of Emacs buffers nor the random evaluations of Lisp that modified his instance on the fly in very pointed, task-specific ways.  Additionally, he had perfect recall of every Emacs Lisp function that he had ever written (or so it seemed).
* One could trace the flow of Cosmac 1802 assembly code in his head.  In one afternoon he wrote a complete 1802 emulator in BASIC.
* Two were unbelievable when armed with a C++ compiler.  During the course of a huge integration event they worked together to rewrite a large portion of a misbehaving simulation node that worked without error on every run that week.  One of them moved on to Python and amazingly became even more impressive.

Would you say that Java, Emacs Lisp, Cosmac 1802 assembly, C++, and Python were "elite" languages?  Maybe.  But the fact remains that they certainly seemed "elite" in the hands of "elite" programmers.  I suspect that every language, be it generally viewed as "elite" or mundane, has it's share of programmers that will take your breath away.  I suspect that these programmers would excel given any language, but for some reason certain languages just make sense to them.  I'm of the opinion that programming languages are a subjective affair.

Languages do not make a programmer "elite" and anyone that says otherwise is trying to sell you something, or selling themselves short.  There is no doubt that there are some programmers who are unbelievably productive and dare I say "elite", but it's not the language that got them there.  I suspect that for any programmer there is some set of languages that can help them to crystalize their thought processes.  You might say that certain languages attract "elite" programmers, but I'm skeptical about that.

I've been fortunate enough to work closely with two programmers and corresponded with another who created fairly popular programming languages.  In my limited experience it's always been the case that the language designers are the most tempered in the view concerning the universality of their creations.  However, like any social group it's others, often those not directly connected with the stewardship of said language who make the grandest and most universal claims.  Alas this is an ugly side of the programming beast.

## "Elite" Problems

Programming is hard.  However, there are relative levels of difficulty.  A text-editor is harder than the Towers of Hanoi and likewise an operating system is harder than a text-editor.  Having said that, there *are* languages that are designed to solve hard problems.  Clojure is one such language. Regardless, there is nothing stopping one from using Clojure to write Towers of Hanoi or text-editors.  The "solving hard problems" bit simply means that the language itself provides first-class abstractions and features that encapsulate techniques and semantics to alleviate difficult problems.  For example, in the case of Clojure you might say this about its immutable types and STM.  Ironically, it's these very features that make these "elite" problems easier to reason about, so what does that say?  Is the language easier, or is it harder?  I don't think that I have the a definitive answer, but you might guess at my opinion.

## "Elite"

So why does the term "elite" become attached to certain languages over others?  I think that there are many factors, both social and psychological that play into this.  Since I'm neither a sociologist nor a psychologist I can't say for sure.  However, I must say that the idea of an "elite" programming language just does not seem right to me.  For better or worse I only have my opinions, experiences,  anecdotes, and my own notion of what makes sense to offer.

Caveat emptor.

:F
